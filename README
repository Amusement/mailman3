Mailman - The GNU Mailing List Management System
Copyright (C) 1998 by the Free Software Foundation, Inc.
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA

                              Background
                              ==========
This is Mailman, a mailing list management system written mostly in
Python.  Mailman was originally developed by John Viega.  Subsequent
development (through version 1.0b3) was by Ken Manheimer.  Currently,
Mailman development is a group effort, led by John Viega, Ken
Manheimer, Barry Warsaw, and Scott Cotton, with contributions from
many - see the address of the mailman-developers list page, below.
See the Mailman home site for current status, including new releases
and known problems: http://www.list.org .

To join the Mailman user's mailing list (recommended) - and to see an
example of a Mailman list interface in action - visit:

    http://www.python.org/mailman/listinfo/mailman-users

To track, and/or participate in, the mailman development crowd:

    http://www.python.org/mailman/listinfo/mailman-developers

See file DONE for info on changes since v. 0.9

Features:

  o Most standard mailing list features, including:
        moderation, mail based commands, digests, etc...
  o An extensive Web interface customizable on a per-list basis.
  o Web based list administration interface for *all* admin-type tasks.
  o Automatic Web based hypermail-style archives (using pipermail or
    other external archiver), including provisions for private archives
  o Integrated mail list to newsgroup gatewaying
  o Integrated newsgroup to mail list gatewaying (polling-based... if you
     have access to the nntp server, you should be able to easily do 
     non-polling based news->mail list gatewaying; email viega@list.org, 
     I'd like to help get that going and come up
     with instructions)
  o Smart bounce detection and correction
  o Integrated fast bulk mailing (useful for sendmail users)
  o Smart spam protection
  o Extensible logging
  o Multiple list owners and moderators are possible
  o Optional MIME-compliant digests
  o Nice about which machine you subscribed from if you're from the
        right domain.


                            Using Mailman
                            =============
Requirements:

  [XXX: This needs to be reviewed]

  You must  be root on a machine  running a mail transport  program that
  uses an /etc/aliases file, and has a sendmail executable (smail should
  be OK).  We will    soon be switching     over to use a  direct   SMTP
  connection to  whatever  you have  running  on port   25.  The machine
  really needs to have a web server in order to configure lists.

Install:
  Please see the file INSTALL for details on installing Mailman.  In the
  instructions that follow, all file paths are assumed to be relative to
  the installation directory $prefix.

Adding a new list:
  o Run the program bin/newlist
  o Visit the list general admin page, and use the descriptions and
    the "details" help feature to understand the configuration settings.

List managers, note that:

  o Being a list administrator does not entail receiving the traffic - 
    you have to subscribe, as well.
  o Relevant urls - the DEFAULT_URL plus:
    - mailman/listinfo/listname for public view of list
    - mailman/admin/listname for options
    - mailman/admindb/listname for pending requests
    - and generally, mailman/listinfo for the list of (public) lists

How to add a new user option

    You'll need to do some of these things and not others.

        1) Add a flag to mm_defaults.py, and mm_cfg.py.dist if it's
           likely to require a custom value for each site.
        2) Add an entry to mm_html GetStandardReplacements name
         & mapping, to enable referring to the value from mailman html.
        3) Add replacements lines to the cgi/options and cgi/listinfo
           scripts, to hook the mailman html up with the option.
        4) For user-specific options, make SetUserOption calls in
         & cgi/handle_opts.
        5) For user-specific options, add to 2 data structs at top of
         &  mm_mailcmd.
        6) For user-specific options, add description to mm_mailcmd help
        7) Update templates if the options have replacements
        8) Use your option wherever appropriate...

Interactive python sessions with maillists

    You  can  do substantial  things  with maillists from the interpreter!
    Include the mailman  homedir on  your shell  python path, or  manually
    insert it on sys.path  from within python, and import Mailman.MailList
    and Mailman.Utils  from within the  interpreter.  You  can instantiate
    the maillist of your choice, eg for a list named postal:

>>> sys.path.insert(0, '/local/mailman')
>>> from Mailman import MailList, Utils
>>> l = MailList.MailList('postal', lock=0)

    (Don't set lock=0 if  you're  going to  be  changing the state of  the
    list, eg adding or  removing  members, etc.   However, be  aware  that
    while you're locking  it you'll be blocking  any other  processes that
    are trying to obtain the lock -  including handling of new postings to
    the list, subscriptions, administrative changes, and so forth.)

    Now you can examine various aspects of the list:

>>> l.members
['klm@python.org']
>>> l.digest_members
[]
>>> l.real_name
'Postal'
>>> l._internal_name
'postal'

    dir(l) will present the  components  of the list. MailList.py  has
    the descriptions of many of them, though some are defined in other
    modules.

    If you  want to save changes, 'l.Save()'  will do it.  It's a real
    good  idea to  play with   trial lists, first,  before using  this
    method to do surgery on production lists!

    When you  do get  comfortable with it,  you use  it and  a utility
    routine, Utils.map_maillists(),  to do batched  changes on all
    your lists.  It takes a function as its argument, and applies that
    function to every one of the  lists on your system.  For instance,
    to get the  names of  all   the lists on   your system  which  are
    advertised:

>>> def advertised(lst):
...    if lst.advertised: return lst.real_name
...
>>> advertised(l)
>>> filter(None, Utils.map_maillists(advertised))
['Mailman-Developers', 'Meta-sig', 'Python-Help', 'C++-SIG', 'Matrix-SIG',
'DB-SIG', 'DO-SIG', 'Doc-SIG', 'GUI-SIG', 'Image-SIG', 'Objc-SIG',
'Plot-SIG', 'Pythonmac-SIG', 'String-SIG', 'Thread-SIG', 'Grail', 'XML-SIG',
'JPython-Interest', 'Trove-Dev', 'Mailman-Users']

    Beware that "list surgery" can be easily used to foul up your list
    data structures - so be careful, and confident of what you're
    done *before* any list .Save()'s are applied...



Local Variables:
mode: indented-text
indent-tabs-mode: nil
End:
