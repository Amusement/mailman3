#! /usr/bin/env python
#
# Copyright (C) 1998 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""Process listinfo form submission, ie subscriptions or roster requests."""

import sys
import os, cgi, string
from regsub import gsub
import paths                                      # path hacking
import mm_utils, maillist, mm_err, mm_message, mm_cfg, mm_pending, htmlformat

try:
    sys.stderr = mm_utils.StampedLogger("error", label = 'subscribe',
                                        manual_reprime=1, nofail=0)
except IOError:
    pass                        # Oh well - SOL on redirect, errors show thru.

doc = htmlformat.Document()

path = os.environ['PATH_INFO']
list_info = mm_utils.GetPathPieces(path)
list_name = string.lower(list_info[0])

if len(list_info) < 1:
    doc.AddItem(htmlformat.Header(2, "Error"))
    doc.AddItem(htmlformat.Bold("Invalid options to CGI script."))
    print doc.Format()
    sys.exit(0)

try:
  list = maillist.MailList(list_name)
except:
  doc.AddItem(htmlformat.Header(2, "Error"))
  doc.AddItem(htmlformat.Bold("%s: No such list." % list_name ))
  print doc.Format()
  sys.exit(0)


if not list._ready:
    doc.AddItem(htmlformat.Header(2, "Error"))
    doc.AddItem(htmlformat.Bold("%s: No such list." % list_name ))
    print doc.Format()
    sys.exit(0)

form = cgi.FieldStorage()

error = 0
results = ''

def call_script(which, pathinfo):
    "A little bit of a hack to call one of the scripts..."
    os.environ['PATH_INFO'] = string.join(pathinfo, '/')
    file = os.path.join(mm_cfg.MAILMAN_DIR, 'cgi/%s' % which)
    list.Unlock()
    execfile(file)
    sys.exit(0)

#######
# Preliminaries done, actual processing of the form input below.

if (form.has_key("UserOptions")
      or (form.has_key("info") and not form.has_key("email"))):
    # Go to user options section.
    if not form.has_key("info"):
	doc.AddItem(htmlformat.Header(2, "Error"))
        doc.AddItem(htmlformat.Bold("You must supply your email address."))
	doc.AddItem(list.GetMailmanFooter())
	print doc.Format()
	sys.exit(0)
    addr = form['info'].value
    member = list.FindUser(addr)
    if not list.FindUser(addr):
	doc.AddItem(htmlformat.Header(2, "Error"))
        doc.AddItem(htmlformat.Bold("%s has no subscribed addr <i>%s</i>."
                                    % (list.real_name, addr)))
	doc.AddItem(list.GetMailmanFooter())
	print doc.Format()
	sys.exit(0)
    call_script('options', [list._internal_name, member])
if not form.has_key("email"):
    error = 1
    results = results + "You must supply a valid email address.<br>"
else:
    email = form["email"].value
if not form.has_key("pw") or not form.has_key("pw-conf"):
    error = 1
    results = results + "You must supply a valid password, and confirm it.<br>"
else:
    pw  = form["pw"].value
    pwc = form["pw-conf"].value

if not error and (pw <> pwc):
    error = 1
    results = results + "Your passwords did not match.<br>"

if form.has_key("digest"):
    digest = eval(form["digest"].value)

if not list.digestable:
    digest = 0
elif not list.nondigestable:
    digest = 1


def PrintResults():
    replacements = list.GetStandardReplacements()
    replacements['<mm-results>'] = results
    output = list.ParseTags('subscribe.html', replacements)

    doc.AddItem(output)
    print doc.Format()
    list.Unlock()
    sys.exit(0)

if error:
    PrintResults()

else:
    try:
        results = results + ("Confirmation from your email address is "
                             "required, to prevent anyone from covertly "
                             "subscribing you.  Instructions are being "
                             "sent to you at %s." % email)
        if os.environ.has_key('REMOTE_HOST'):
            remote = os.environ['REMOTE_HOST']
        elif os.environ.has_key('REMOTE_ADDR'):
            remote = os.environ['REMOTE_ADDR']
        else:
            remote = "."
        if digest:
            digesting = " digest"
        else:
            digesting = ""
        cookie = mm_pending.gencookie()
        mm_pending.add2pending(email, pw, digest, cookie)
        list.SendTextToUser(subject = "%s -- confirmation of subscription -- request %d" % \
                            (list.real_name, cookie),
                            recipient = email,
                            sender = list.GetRequestEmail(),
                            text = mm_pending.VERIFY_FMT % ({"email": email,
                                                             "listaddress": list.GetListEmail(),
                                                             "listname": list.real_name,
                                                             "cookie": cookie,
                                                             "requestor": remote,
                                                             "request_addr": list.GetRequestEmail()}),
                            
                            add_headers = ["Reply-to: %s"
                                           % list.GetRequestEmail(),
                                           "Errors-To: %s"
					   % list.GetAdminEmail()])
    except mm_err.MMBadEmailError:
	results = results + ("Mailman won't accept the given email "
			     "address as a valid address. (Does it "
			     "have an @ in it???)<p>")
    except mm_err.MMListNotReady:
        results = results + ("The list is not fully functional, and "
			     "can not accept subscription requests.<p>")
#
# deprecating this, it might be useful if we decide to
# allow approved based subscriptions without confirmation
#
##     except mm_err.MMNeedApproval, x:
##         results = results + ("Subscription was <em>deferred</em> "
## 			     "because:<br> %s<p>Your request must "
## 			     "be approved by the list admin.  "
## 			     "You will receive email informing you "
## 			     "of the moderator's descision when they "
##			     "get to your request.<p>" % x)
    except mm_err.MMHostileAddress:
        results = results + ("Your subscription is not allowed because "
			     "the email address you gave is insecure.<p>")
    except mm_err.MMAlreadyAMember:
        results = results + "You are already subscribed!<p>"
	

PrintResults()
