================
List memberships
================

Users represent people in Mailman.  Users control email addresses, and rosters
are collections of members.  A member gives an email address a role, such as
`member`, `administrator`, or `moderator`.  Even nonmembers are represented by
a roster.

Roster sets are collections of rosters and a mailing list has a single roster
set that contains all its members, regardless of that member's role.

Mailing lists and roster sets have an indirect relationship, through the
roster set's name.  Roster also have names, but are related to roster sets
by a more direct containment relationship.  This is because it is possible to
store mailing list data in a different database than user data.

When we create a mailing list, it starts out with no members.
::

    >>> mlist = create_list('test@example.com')

    >>> def print_addresses(roster_addresses):
    ...     sorted_addresses = sorted(
    ...         address.address for address in roster_addresses)
    ...     if len(sorted_addresses) == 0:
    ...         print 'No addresses'
    ...     else:
    ...         for address in sorted_addresses:
    ...             print address

    >>> print_addresses(mlist.members.members)
    No addresses
    >>> sorted(user.real_name for user in mlist.members.users)
    []
    >>> sorted(address.address for member in mlist.members.addresses)
    []

...no owners...

    >>> print_addresses(mlist.owners.members)
    No addresses
    >>> sorted(user.real_name for user in mlist.owners.users)
    []
    >>> sorted(address.address for member in mlist.owners.addresses)
    []

...no moderators...

    >>> print_addresses(mlist.moderators.members)
    No addresses
    >>> sorted(user.real_name for user in mlist.moderators.users)
    []
    >>> sorted(address.address for member in mlist.moderators.addresses)
    []

...and no administrators...

    >>> print_addresses(mlist.administrators.members)
    No addresses
    >>> sorted(user.real_name for user in mlist.administrators.users)
    []
    >>> sorted(address.address for member in mlist.administrators.addresses)
    []

...and no nonmembers.

    >>> print_addresses(mlist.nonmembers.members)
    No addresses
    >>> sorted(user.real_name for user in mlist.nonmembers.users)
    []
    >>> sorted(address.address for member in mlist.nonmembers.addresses)
    []


Administrators
==============

A mailing list's administrators are defined as union of the list's owners and
the list's moderators.  We can add new owners or moderators to this list by
assigning roles to users.  First we have to create the user, because there are
no users in the user database yet.

    >>> from mailman.interfaces.usermanager import IUserManager
    >>> from zope.component import getUtility
    >>> user_manager = getUtility(IUserManager)
    >>> user_1 = user_manager.create_user('aperson@example.com', 'Anne Person')
    >>> print user_1.real_name
    Anne Person
    >>> print_addresses(user_1.addresses)
    aperson@example.com

We can add Anne as an owner of the mailing list, by creating a member role for
her.

    >>> from mailman.interfaces.member import MemberRole
    >>> address_1 = list(user_1.addresses)[0]
    >>> print address_1.address
    aperson@example.com
    >>> address_1.subscribe(mlist, MemberRole.owner)
    <Member: Anne Person <aperson@example.com> on
             test@example.com as MemberRole.owner>
    >>> print_addresses(mlist.owners.members)
    Anne Person <aperson@example.com>
    >>> sorted(user.real_name for user in mlist.owners.users)
    [u'Anne Person']
    >>> print_addresses(mlist.owners.addresses)
    aperson@example.com

Adding Anne as a list owner also makes her an administrator, but does not make
her a moderator.  Nor does it make her a member of the list.

    >>> sorted(user.real_name for user in mlist.administrators.users)
    [u'Anne Person']
    >>> sorted(user.real_name for user in mlist.moderators.users)
    []
    >>> sorted(user.real_name for user in mlist.members.users)
    []

We can add Bart as a moderator of the list, by creating a different member role
for him.

    >>> user_2 = user_manager.create_user('bperson@example.com', 'Bart Person')
    >>> print user_2.real_name
    Bart Person
    >>> address_2 = list(user_2.addresses)[0]
    >>> print address_2.address
    bperson@example.com
    >>> address_2.subscribe(mlist, MemberRole.moderator)
    <Member: Bart Person <bperson@example.com>
             on test@example.com as MemberRole.moderator>
    >>> print_addresses(mlist.moderators.members)
    Bart Person <bperson@example.com>
    >>> sorted(user.real_name for user in mlist.moderators.users)
    [u'Bart Person']
    >>> print_addresses(mlist.moderators.addresses)
    bperson@example.com

Now, both Anne and Bart are list administrators.

    >>> print_addresses(mlist.administrators.members)
    Anne Person <aperson@example.com>
    Bart Person <bperson@example.com>
    >>> sorted(user.real_name for user in mlist.administrators.users)
    [u'Anne Person', u'Bart Person']
    >>> print_addresses(mlist.administrators.addresses)
    aperson@example.com
    bperson@example.com


Members
=======

Similarly, list members are born of users being given the proper role.  It's
more interesting here because these roles should have a preference which can
be used to decide whether the member is to get regular delivery or digest
delivery.  Without a preference, Mailman will fall back first to the address's
preference, then the user's preference, then the list's preference.  Start
without any member preference to see the system defaults.

    >>> user_3 = user_manager.create_user(
    ...     'cperson@example.com', 'Cris Person')
    >>> print user_3.real_name
    Cris Person
    >>> address_3 = list(user_3.addresses)[0]
    >>> print address_3.address
    cperson@example.com
    >>> address_3.subscribe(mlist, MemberRole.member)
    <Member: Cris Person <cperson@example.com>
             on test@example.com as MemberRole.member>

Cris will be a regular delivery member but not a digest member.

    >>> print_addresses(mlist.members.addresses)
    cperson@example.com
    >>> print_addresses(mlist.regular_members.addresses)
    cperson@example.com
    >>> print_addresses(mlist.digest_members.addresses)
    No addresses

It's easy to make the list administrators members of the mailing list too.

    >>> members = []
    >>> for address in mlist.administrators.addresses:
    ...     member = address.subscribe(mlist, MemberRole.member)
    ...     members.append(member)
    >>> sorted(members, key=lambda m: m.address.address)
    [<Member: Anne Person <aperson@example.com> on
              test@example.com as MemberRole.member>,
     <Member: Bart Person <bperson@example.com> on
              test@example.com as MemberRole.member>]
    >>> print_addresses(mlist.members.addresses)
    aperson@example.com
    bperson@example.com
    cperson@example.com
    >>> print_addresses(mlist.regular_members.addresses)
    aperson@example.com
    bperson@example.com
    cperson@example.com
    >>> print_addresses(mlist.digest_members.addresses)
    No addresses


Nonmembers
==========

Nonmembers are used to represent people who have posted to the mailing list
but are not subscribed to the mailing list.  These may be legitimate users who
have found the mailing list and wish to interact without a direct
subscription.  It may also be spammers who should never be allowed to contact
the mailing list.  Because all the same moderation rules can be applied to
nonmembers, we represent them as the same type of object but with a different
role.

    >>> user_6 = user_manager.create_user('fperson@example.com', 'Fred')
    >>> address_6 = list(user_6.addresses)[0]
    >>> member_6 = address_6.subscribe(mlist, MemberRole.nonmember)
    >>> member_6
    <Member: Fred <fperson@example.com> on test@example.com
             as MemberRole.nonmember>
    >>> print_addresses(mlist.nonmembers.addresses)
    fperson@example.com

Nonmembers do not get delivery of any messages.  See that Fred does not show
up in any of the delivery rosters.

    >>> print_addresses(mlist.members.addresses)
    aperson@example.com
    bperson@example.com
    cperson@example.com
    >>> print_addresses(mlist.regular_members.addresses)
    aperson@example.com
    bperson@example.com
    cperson@example.com
    >>> print_addresses(mlist.digest_members.addresses)
    No addresses


Finding members
===============

You can find the ``IMember`` object that is a member of a roster for a given
text email address by using the ``IRoster.get_member()`` method.

    >>> mlist.owners.get_member('aperson@example.com')
    <Member: Anne Person <aperson@example.com> on
             test@example.com as MemberRole.owner>
    >>> mlist.administrators.get_member('aperson@example.com')
    <Member: Anne Person <aperson@example.com> on
             test@example.com as MemberRole.owner>
    >>> mlist.members.get_member('aperson@example.com')
    <Member: Anne Person <aperson@example.com> on
             test@example.com as MemberRole.member>
    >>> mlist.nonmembers.get_member('fperson@example.com')
    <Member: Fred <fperson@example.com> on
             test@example.com as MemberRole.nonmember>

However, if the address is not subscribed with the appropriate role, then None
is returned.

    >>> print mlist.administrators.get_member('zperson@example.com')
    None
    >>> print mlist.moderators.get_member('aperson@example.com')
    None
    >>> print mlist.members.get_member('zperson@example.com')
    None
    >>> print mlist.nonmembers.get_member('aperson@example.com')
    None


All subscribers
===============

There is also a roster containing all the subscribers of a mailing list,
regardless of their role.

    >>> def sortkey(member):
    ...     return (member.address.address, int(member.role))
    >>> for member in sorted(mlist.subscribers.members, key=sortkey):
    ...     print member.address.address, member.role
    aperson@example.com MemberRole.member
    aperson@example.com MemberRole.owner
    bperson@example.com MemberRole.member
    bperson@example.com MemberRole.moderator
    cperson@example.com MemberRole.member
    fperson@example.com MemberRole.nonmember


Double subscriptions
====================

It is an error to subscribe someone to a list with the same role twice.

    >>> address_1.subscribe(mlist, MemberRole.owner)
    Traceback (most recent call last):
    ...
    AlreadySubscribedError: aperson@example.com is already a MemberRole.owner
    of mailing list test@example.com


Moderation actions
==================

All members of any role have a *moderation action* which specifies how
postings from that member are handled.  By default, owners and moderators are
automatically accepted for posting to the mailing list.

    >>> from operator import attrgetter
    >>> for member in sorted(mlist.administrators.members,
    ...                      key=attrgetter('address.address')):
    ...     print member.address.address, member.role, member.moderation_action
    aperson@example.com MemberRole.owner Action.accept
    bperson@example.com MemberRole.moderator Action.accept

By default, members have a *deferred* action which specifies that the posting
should go through the normal moderation checks.

    >>> for member in sorted(mlist.members.members,
    ...                      key=attrgetter('address.address')):
    ...     print member.address.address, member.role, member.moderation_action
    aperson@example.com MemberRole.member Action.defer
    bperson@example.com MemberRole.member Action.defer
    cperson@example.com MemberRole.member Action.defer

Postings by nonmembers are held for moderator approval by default.

    >>> for member in mlist.nonmembers.members:
    ...     print member.address.address, member.role, member.moderation_action
    fperson@example.com MemberRole.nonmember Action.hold
