#! /usr/bin/env python
#
# Copyright (C) 1998 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""Clone a member address.

Cloning a member address means that a new member will be added who has all the
same options and passwords as the original member address.  Note that this
operation is fairly trusting of the user who runs it -- it does no
verification to the new address, it does not send out a welcome message, etc.

The existing member's subscription is not modified in any way.  If you want to
remove it, you need to run the `remove_members' script explicitly.

Usage:
    clone_member [-h] listname fromaddr toaddr

Where:

    --help
    -h
        Print this help message and exit.

    listname is the name of the mailing list to find the address on.

    fromaddr is the address of the user to clone from

    toaddr is the address of the user to clone to

"""

import sys
import string
import getopt
import paths

import Mailman.MailList
import Mailman.Utils
import Mailman.Errors

def usage(status, msg=''):
    print __doc__ % globals()
    if msg:
        print msg
    sys.exit(status)



def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'h', ['help'])
    except getopt.error, msg:
        usage(1, msg)

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage(0)

    if len(args) <> 3:
        usage(1)

    listname = args[0]
    fromaddr = args[1]
    toaddr = args[2]

    try:
        # open locked
        mlist = Mailman.MailList.MailList(listname)
    except Mailman.Errors.MMUnknownListError:
        print 'No list:', listname
        sys.exit(1)

    # validate and normalize
    try:
        Mailman.Utils.ValidateEmail(toaddr)
    except Mailman.Errors.EmailAddressError:
        print 'Not a valid email address:', toaddr
    lfromaddr = string.lower(fromaddr)

    # see if the fromaddr is a digest member or regular member
    dmembers = mlist.GetDigestMembers()
    rmembers = mlist.GetMembers()
    if lfromaddr in dmembers:
        digest = 1
    elif lfromaddr in rmembers:
        digest = 0
    else:
        print 'No user:', fromaddr
        return

    # Get the user's current options and password.  TBD: Ugly hack: if a
    # user's options would have been zero, then Mailman saves room by deleting
    # the entry for the user from the user_options dictionary.  Note that
    # /really/ it would be better if Mailman.GetUserOption() and
    # Mailman.SetUserOption() supported an interface to get the entire option
    # value.
    options = mlist.user_options.get(lfromaddr, 0)
    password = mlist.passwords[lfromaddr]

    # now add the new user
    try:
        mlist.ApprovedAddMember(toaddr, password, digest, 0)
    except Mailman.Errors.MMAlreadyAMember:
        print 'Already a member:', toaddr

    # and finally hack the options
    cftoaddr = string.lower(toaddr)
    if not options:
        try:
            del mlist.user_options[cftoaddr]
        except KeyError:
            # the user's options were already zero
            pass
    else:
        mlist.user_options[cftoaddr] = options
    mlist.Save()


if __name__ == '__main__':
    main()
