#! /usr/bin/env python

"""Use this script to help you update to the latest release of Mailman from
some previous version.  It knows about versions back to 1.0b4 (?).

"""

import sys, os, string
import paths
from Mailman.MailList import MailList
from Mailman.Utils import list_names
import Mailman.mm_cfg



def makeabs(relpath):
    return os.path.join(Mailman.mm_cfg.PREFIX, relpath)



def dolist(list):
    l = MailList(list)

    mbox_dir = makeabs('archives/private/%s.mbox' % (list))
    mbox_file = makeabs('archives/private/%s.mbox/%s' % (list, list))

    o_pub_mbox_file = makeabs('archives/public/%s' % (list))
    o_pri_mbox_file = makeabs('archives/private/%s' % (list))

    html_dir = o_pri_mbox_file
    o_html_dir = makeabs('public_html/archives/%s' % (list))
    #
    # make the mbox directory if it's not there.
    #
    if not os.path.exists(mbox_dir):
        ou = os.umask(0)
        os.mkdir(mbox_dir, 02775)
        os.umask(ou)
    else:
        # this shouldn't happen, but hey, just in case
        if not os.path.isdir(mbox_dir):
            print "for some reason", mbox_dir, \
                  "exists as a file.  This won't work with b6"
            print "so I'm renaming it to %s.tmp and proceeding" % (mbox_dir)
            os.rename(mbox_dir, "%s.tmp" % (mbox_dir))
            ou = os.umask(0)
            os.mkdir(mbox_dir, 02775)
            os.umask(ou)

    # Move any existing mboxes around, but watch out for both a public and a
    # private one existing
    if os.path.isfile(o_pri_mbox_file) and os.path.isfile(o_pub_mbox_file):
        if l.archive_private:
            print """\
%s has both public and private mbox archives, since this list
currently uses private archiving, I'm installing the private mbox
archive (%s) as the active archive, and renaming
	%s
to
	%s.preb6

You can integrate that into the archives if you want by using the 'arch'
script.
""" % (l._internal_name, o_pri_mbox_file, o_pub_mbox_file, o_pub_mbox_file)
            os.rename(o_pub_mbox_file, "%s.preb6" % (o_pub_mbox_file))
        else:
            print """\
%s has both public and private mbox archives.  Since this list
currently uses public archiving, I'm installing the public mbox file
archive file (%s) as the active one, and renaming
	%s
    to
    	%s.preb6

You can integrate that into the archives if you want by using the 'arch'
script.
""" % (l._internal_name, o_pub_mbox_file, o_pri_mbox_file, o_pri_mbox_file)
            os.rename(o_pri_mbox_file, "%s.preb6" % (o_pri_mbox_file))
    #
    # move private archive mbox there if it's around
    # and take into account all sorts of absurdities
    #
    print '- updating old private mbox file'
    if os.path.exists(o_pri_mbox_file):
        if os.path.isfile(o_pri_mbox_file):
            os.rename(o_pri_mbox_file, mbox_file)
        elif not os.path.isdir(o_pri_mbox_file):
            newname = "%s.mm_install-dunno_what_this_was_but_its_in_the_way" \
                      % o_pri_mbox_file
            os.rename(o_pri_mbox_file, newname)
            print "    unknown file in the way, moving"
            print "        " + o_pri_mbox_file
            print "    to"
            print "        " + newname
        else:
            # directory
            print "    looks like you have a really recent CVS installation..."
            print "    you're either one brave soul, or you already ran me"
    

    #
    # move public archive mbox there if it's around
    # and take into account all sorts of absurdities.
    #
    print '- updating old public mbox file'
    if os.path.exists(o_pub_mbox_file):
        if os.path.isfile(o_pub_mbox_file):
            os.rename(o_pub_mbox_file, mbox_file)
        elif not os.path.isdir(o_pub_mbox_file):
            newname = "%s.mm_install-dunno_what_this_was_but_its_in_the_way" \
                      % o_pub_mbox_file
            os.rename(o_pub_mbox_file, newname)
            print "    unknown file in the way, moving"
            print "        " + o_pub_mbox_file
            print "    to"
            print "        " + newname
        else: # directory
            print "    looks like you have a really recent CVS installation..."
            print "    you're either one brave soul, or you already ran me"

    #
    # move the html archives there
    #
    if os.path.isdir(o_html_dir):
        os.rename(o_html_dir, html_dir)
        #
        # chmod the html archives
        #
        os.chmod(html_dir, 02775)
    #
    # save the new variables and
    # let it create public symlinks if necessary
    #
    l.archive_directory = makeabs('archives/private/%s' % (list))
    l.private_archive_file_dir = makeabs('archives/private/%s.mbox' % (list))
    l.Save()
    #
    # check to see if pre-b4 list-specific templates are around
    # and move them to the new place if there's not already
    # a new one there
    #
    tmpl_dir = os.path.join(Mailman.mm_cfg.PREFIX, "templates")
    list_dir = os.path.join(Mailman.mm_cfg.PREFIX, "lists")
    b4_tmpl_dir = os.path.join(tmpl_dir, l._internal_name)
    new_tmpl_dir = os.path.join(list_dir, l._internal_name)
    if os.path.exists(b4_tmpl_dir):
	print "- This list looks like it might have <= b4 " \
              'list templates around'
        for f in os.listdir(b4_tmpl_dir):
            o_tmpl = os.path.join(b4_tmpl_dir, f)
            n_tmpl = os.path.join(new_tmpl_dir, f)
            if not os.path.exists(n_tmpl):
                os.rename(o_tmpl, n_tmpl)
                print "- moved %s to %s" % (o_tmpl, n_tmpl)
            else:
                print "- both %s and %s exist, leaving untouched" \
                      % (o_tmpl, n_tmpl)
    # Avoid eating filehandles with the list lockfiles
    l.Unlock()

#
# this function is passed to os.path.walk
# to fix the perms on old html archives.
#
def archive_path_fixer(unused_arg, dir, files):
    for f in files:
        abs = os.path.join(dir, f)
        if os.path.isdir(abs):
            if f == "database":
                os.chmod(abs, 02770)
            else:
                os.chmod(abs, 02775)
        elif os.path.isfile(abs):
            os.chmod(abs, 0664)

def remove_old_sources(module):
    src = "%s/%s" % (Mailman.mm_cfg.PREFIX, module)
    pyc = src + "c"
    if os.path.exists(src):
        print "removing", src
        try:
            os.unlink(src)
        except os.error, rest:
            print "Warning: couldn't remove", src, "--", str(rest)
    if module[-3:] == '.py' and os.path.exists(pyc):
        try:
            os.unlink(pyc)
        except os.error, rest:
            print "couldn't remove old file", pyc, "--", str(rest)


if __name__ == '__main__':
    for mod in ('Mailman/Archiver.py', 'Mailman/HyperArch.py',
                'Mailman/HyperDatabase.py', 'Mailman/pipermail.py',
                'Mailman/smtplib.py',
                'bin/update_to_10b6'):
        remove_old_sources(mod)
    lists = list_names()
    if not lists:
        print "no lists == nothing to do, exiting"
        sys.exit(0)
    #
    # for people with web archiving, make sure the directories
    # in the archiving are set with proper perms for b6.
    #
    if os.path.isdir("%s/public_html/archives" % Mailman.mm_cfg):
        print "fixing all the perms on your old html archives to work with b6"
        print "If your archives are big, this could take a minute or two..."
        os.path.walk("%s/public_html/archives" % Mailman.mm_cfg,
                     archive_path_fixer, "")
        print "done"
    for list in lists:
        print 'Updating mailing list: ', list
        dolist(list)
    print '\nNOTE NOTE NOTE NOTE NOTE'
    print """You will need to manually update your mailing lists.
For each mailing list you need to copy the file templates/options.html
lists/<listname>/options.html.

However, if you have edited this file via the Web interface, you will have to
merge your changes into this file, otherwise you will lose your changes.
"""
    
