		  Mailman - Extensibility and Python
		  ==================================

       Motivation: Internet dynamicism calls for adaptable MLMs

From the early days of the ARPAnet to today, email and Mailing List
Management (MLM) systems have played a crucial role in the formation
and conduct of communities on the internet.  With the profound
dynamicism of the internet, the form of those communities has
tremendous potential for continued growth and evolution.  The extent
to which MLMs are versatile and adaptable is the extent to which they
can accomodate, and even foster, effective new forms of community
organization.  Mailman is well suited to such evolution, and one of
the contributing features is its basis in Python.

In this paper we will look at various ways the versatility of the
system enables extension of it, considering how the system's design
and its implementation language, Python, factor into it.

Why Versatility?

Why is extensibility and susceptibility to change important in a
contemporary MLM?  It is because of the explosive growth in the
internet community, and the core role that email plays in it.  The
internet community is growing, and the infrastructures by which it
organizes are evolving.  Over time, changes in the scale and
development of improved and new strategies for organizing of internet
communities demand continuing development of the mechanisms supporting
them.  A good MLM will foster that evolution by growing with it.

Another reason for the importance of extensibility has to do with a
core constituency of the maillist users - the maillist administrators.
These administrators are typically near enough to the end-users to get
clear impressions of their needs.  Also, they commonly are savvy
enough, technically, to be able to implement improvements to
accomodate those needs - provided the system doesn't present too high
a threshold of comprehension.  Here is a prime opportunity for
exploiting the Bazaar-style of open-software development [klm: cite
esr's paper], enabling the managers of the medium, themselves, to
guide its development, enabling results more quickly and closely
tailored to the needs of the user community.

Finally, most aspects of an MLM do not require the kind of speed
optimizations which force change-impeding hardening of system.
Performance critical aspects, like mail delivery to large numbers of
users, is generally the purview of the underlying Mail Transport
Agents (MTAs), not the MLM.  Large capacities can impose some
specialized performance demands on the MLM, of course.  The speciality
of those demands, however, enables isolating the optimizations to
select components, and Python's compiled-language extensibility
enables hardening those specific components as needed, isolating the
rigidity to the particular subsystems that need it.

Why Python?

Python is particularly well suited to to implementing an extensive and
changing system.  Its combination of clean syntax and cogent semantics
aids the programmer, all the more in the process of changing existing
code.  It is dynamic in many respects, enabling interaction with and
programmatic handling of just about everything in the language.  By
satisfying the needs of prototyping and rapid development, as well as
those of general programming, it can be seen to foster the needs of
"continuous development", where a system needs to continue to grow to
accomodate a changing world.

		  An Overview of Mailman's Structure
		  ==================================

[klm: barry's stuff will go in here.]

	      A Selective Tour of Mailman's Versatility
	      =========================================

	       MailList Object Composed via Inheritance
		    from Task-Oriented Components

The MailList class is composed by multiple inheritance from a number
of task-oriented component classes, as mixins.  The task oriented
components contain the methods and variable declarations and
initializations related to the functionality of a particular
subsystem, for example, that of the delivery mechanism or of the mail
commands handler.  This enables easy sharing of their methods and data
throughout the MailList object.  It avoids the need to explicitly
identify and pass around, for example, delegate instances, in order to
use those component's data and methods.

Having all the methods and data inhabit the namespace of the primary
MailList instance can lead to inadvertant name collisions.  However,
we feel that the system would have to get much bigger before that
would become a practical concern, and then we could use naming
conventions to prevent the collisions while still enjoying the easy
sharing without explicit passing of delegate instances.  This use of
multiple inheritance provides this direct sharing along with
organization of the system in distinct, conceptually motivated
modules, easing debugging and development.

New major modules are still being added.  For instance, as of this
writing one of the primary authors added bidirectional mail/news
gateway capability to mailman.  This module required knowledge of some
boilerplate structure and only minor changes to existing modules,
providing a major functionality with almost plugin-style ease.

		  MailList Object State Persistence
	      Exploits Introspection And Simple Sharing

This direct sharing also simplifies the maillist object's persistence
mechanism.  By identifying its own data members via self.__dict__, the
maillist object's persistence mechanism saves and restores maillist
state using a marshal.  (Members that should not be saved are
distinguished with a leading "_" underscore.)  This exploits Python's
introspection capabilities, as well as a standard, simple persistent
storage facility.  (The higher level standard persistent storage
mechanism, pickle, would do more work than we want or need, so we were
able to avoid its overhead.)  As with sharing in the first place, the
arrangement is uncomplicated, easing approach and acquaintance by
newcomers.

	  Programming and Interacting With MailList Objects

Perhaps the most crucial basis for any versatility, at all, in Mailman
is in manifesting maillists as Python class object instances.  This
enables comprehensive interaction with maillists both programmatically
and incrementally, in the interactive Python shell.  Programmatic
interaction enables us to extend access to any aspect of maillist
operation, anywhere we can write a script.  From this we build Web,
Email, and cron access.  We can also build scripts to automate any
routine procedures, such as conversion of subscriber lists from
established Majordomo mailing lists.

Interactive sessions with maillist instances provides a profoundly
useful development and debugging tool.  Using it, we are able to
exercise and test isolated subsystems, engaging tools like the Python
debugger and profiler along the way.

We can also use interactive sessions do maillist "surgery" - make
changes to list state not provided for in already created scripts.
Using a utility function, map_mailists, we can apply arbitrary
functions to all or selected mailman maillists at the site, doing
wholescale conversions of the maillists to accomodate, for instance, 
changes in the address of the site, or to search for particular
members of any of the maillists, and do some processing on their
subscriptions.

Logging Mechanism

Most of the common interactions with MailList objects are triggered
remotely - via the web or email - or via periodically fired cron
routines.  These operatorless activations can make system failures
hard to trace.  Of course, every program should be perfect (:-), or at
least fail gracefully.  However, when programming in an environment
where change is frequent, we need to provide some defensive mechanisms
which aid the capture of the errors that inevitable slip by.
Mailman's logging mechanism, and the way it is applied, provides that
coverage.

Reliable logging is also key for tracking the occurrance of common
events that otherwise take place "behind the scenes".  This can
include maillist subscription activity, automated change of
subscriptions due to delivery failures, and so forth.  It also is
useful to be able to do "flag-printing" debugging even when stdout
does not go anywhere useful (e.g., when running under CGI, or in
disconnected forked processes, or via email).

Mailman has Logger utility objects whose job it is to reliably direct
messages to log files.  These objects obey the conventional interface
protocol of Python's file-like objects.  They can be used explicitly
by the programmer like standard file object to write messages.

Logger objects can also be substituted for standard output streams
like sys.stderr and sys.stdout, enabling, for instance, blanket
capture of error tracebacks from within the modules where they occur.
Time-stamped logger object and multi-stream output variants are
commonly used within scripts that run disconnected from a terminal, to
capture errors.

Loggers are applied in mailman web-associated components with another
useful refinement.  All Web CGI scripts are launched via a well-tested
driver script, which launches the intended job-specific scripts within
the context of an unqualified try-except statement.  If any exception
escapes the job-specific script - including ones that simply cannot be
caught within a script, for instance, syntax errors, then the driver
catches the exception and handles them in a useful way.  It produces
the traceback and a listing of all the HTTP settings both to stdout
(HTML formatted, for rendition on the Web), and to the error log file.
This way, the web visitor is provided with informative feedback
(including instructions about contacting the site administrator, if
they are inclined), and the site has a detailed record of the error.

Structural incorporation of error logging into the mailman framework
eliminates the need for specific components to do so explicitly, and
increases the incidence of detecting and pinpointing faults early in
the development cycle.  This incorporation depends on Python's
high-level exception mechanism, polymorphism, and a standard
file-object protocols for easy and thorough, no-hassle implementation.

			    Web Interface

Mailman provides an interface to MailList objects via CGI, extending
programmatic access to MailList objects to the World Wide Web.  The
MailList component, HTMLFormatter, contains maillist-specific HTML
widgets, built upon an HTML widget library, also included in mailman.
The underlying library provides a full range of modest HTML document
presentation and CGI form widgets, as well as cookies for
authentication.  By building upon such a general mechanism, any
aspects of maillist operation can be extended to the Web.

For starters, we make simple web-related functionality, like overview
of the maillists on the site, and review and subscription to
particular lists, available via the web.  In addition, we also extend
administrative customization of maillist operation (see [configuration
options], below), administrative action on the disposition of
subscriptions and postings being held for approval, and subscriber
control of their subscription status, customization options, and
password.

The elaborateness of web applications, and the typical lack of a local
operator and error console, can complicate their development and
debugging.  The use of mailman's logging utilities, as described
above, provides reporting of unexpected errors, and also provides
convenient means for debugging flag "printouts" when exercising
mailman's Web interfaces via the Web.

Configuration Options Mechanism Exploits Namespace Dynamicism

One significant subsystem demonstrating interfacing of MailList
objects with the web is the maillist customization-options mechanism.

Sets of configuration options are expressed as lists of tuples, each
tuple specifying the name of the data member which contains the
underlying setting, the type and layout of the element that will
represent it in the HTML user interface, a brief description of the
option, and optional (ie, elective) elaborate description of the
option.  (The option lists also include string entries which are used
to annotate their presentation, typically at least including a header
describing the category of the set.)  Python's dynamic namespaces
enables this simple mechanism to couple external user interface with
the underlying data member.

The elementary nature of the mechanism, in turn, simplifies the
process of adding new configuration variables or changing existing
ones - a common occurrence when new features are added or existing
ones are changed.

The formal structuring of the options has provided another benefit -
it enables central enhancement of the options mechanism as a whole.
One recent example is addition of a help mechanism, which entailed
adding the optional slot for elaborate descriptions and a
corresponding addition to the presentation mechanism to offer help for
those variables that contain the elaborate description.

These option description tables could and should be divided into
plugin directories, to further separate the introduction of new
options from the main body of the program, enabling two benefits:

 - Isolation of the program from disruption due to faults in the
   option descriptions (which tend to be changed more commonly than
   other parts of the program).

 - Reevaluation of the option descriptions while the program is
   running (which will be particularly useful when the program is able 
   to run as a persistent daemon)

Languages lacking the ability to directly access and effect runtime
namespaces could not do any of this without significant and cumbersome
indirection, hence obtuseness of the necessary code.

		Drawbacks, Lessons and Open Questions
		=====================================

The MailList object use of mixins has the drawback that it gathers all
method and data member names in the same namespace.  The requires
defensive programming to avoid collisions.  In practice it is hardly a
problem, except...

The mailman configuration options compound this danger by directly
populating the list object with numerous data members representing the
options values.  We should reduce this load by encapsulating the
options within a class object tailored to getting and setting the the
options as attributes.  This would also afford additional
functionality on options, such as better defaulting relationships - so
that changes to the central defaults are propagated back to maillists
even after their creation time.

Early versions of mailman used broad, unqualified except clauses,
masking unintended exceptions and making it extremely difficult to
track down the origin of faults contained therein.  In practice,
unqualified except clauses should never be used unless the intention
is to catch and actually handle any contained failures.  (Code that
does general failure handling can be seen as an executive of the code
being handled.  For instance, the CGI driver script, which directs the
traceback and debugging info to the appropriate destinations, plays
this role w.r.t. the CGI scripts.)  In general, except clauses should
be as completely qualified as possible, and should be moved as close
to the exception they're meant to catch as can be handled.

One fundamental question involved in producing any large programming
project is the importance of type safety that static typing affords,
and questions about the viability of a dynamically typed system - even
one that is strictly typed - as its scale increases and the project,
of necessity, breaks into separate sub projects.  The relatively new
phenomenon of Bazaar-style open software development adds new facets
to this question.  Does the flexibility of dynamic typing add to or
reduce the approachability of the code, and increase or decrease its
robustness in the face of numerous different developers of differing
skill levels?  Or are these qualities more sensitive to the discipline
and policies of the central maintainers than they are to rigorous
mechanisms like typing.  The authors of this paper have not come to
agreement on any of these questions, and we expect that clear, direct
answers, if any, have yet to be resolved.

			      Conclusion
			      ==========

The desirability for continuing evolution in an MLM suggests a model
of the system as being perpetually unfinished - with at least some
parts at any one time as continuously developing prototypes.  The
system must be amenable to continuing, and possibly deep, change.
Prototyping and rapid development are among Python's clear strengths,
and invaluable in this regard.

Mailman exploits many of Python's features, including native object
orientation, multiple inheritance, polymorphism, high-level control
structures like exceptions, conventional protocols, dynamic access to
namespaces, cogent data structures, standard libraries.  A key aspect
of Python code that's hardly been touched on here, but of great import
in the context of multi-person, bazaar-style projects, is the tendency
to readability fostered by the language's uncluttered syntax and its
promotion of regular layout.  Combined with the power of the language,
this enables development of sophisticated functionality while
maintaining approachable, untortured code.  This has already paid off,
accumulating good implementation-specific suggestions and some
contributed code from the user community this early in mailman's
development.
