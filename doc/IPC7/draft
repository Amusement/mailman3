Mailman - Extensibility and Python
 (was Mailman and the Potency of a Python-Powered MLM)

       Motivation: Internet dynamicism calls for adaptable MLMs

From the early days of the ARPAnet to today, email and Mailing List
Management (MLM) systems have played a crucial role in the formation
and conduct of communities on the internet.  With the profound
dynamicism of the internet, the form of those communities has
tremendous potential for continued growth and evolution.  The extent
to which MLMs are versatile and adaptable is the extent to which they
can accomodate, and even foster, effective new forms of community
organization.  Mailman is well suited to such evolution, and one of
the contributing features is its basis in Python.

In this paper we will look at various ways the versatility of the
system enables extension of it, considering how the system's design
and its implementation language, Python, factor into it.

Why Versatility?

Why is extensibility important in a contemporary MLM?  It is because
of the explosive growth in the internet community, and the core role
that email plays in it.  The internet community is growing, and the
infrastructures by which it organizes are evolving.  Over time,
changes in the scale and development of improved and new strategies
for organizing of internet communities demand continuing development
of the mechanisms supporting them.  A good MLM will foster that
evolution by growing with it.

Another reason the importance of extensibility's has to do with a core
constituency of the maillist users - the maillist administrators.
These administrators are typically near enough to the end-users to get
clear impressions of their needs.  Also, they commonly are savvy
enough, technically, to be able to implement improvements to
accomodate those needs - provided the system doesn't present too high
a threshold of comprehension.  Here is a prime opportunity for
exploiting the Bazaar-style of system development [klm: cite esr's
paper], enabling the managers of the medium, themselves, to guide its
development, so it can be closely tailored to the needs of the
community using it.

Finally, most aspects of an MLM do not require the kind of speed
optimizations which force change-impeding hardening of system.
Performance critical aspects, like mail delivery to large numbers of
users, is generally the purview of the underlying Mail Transport
Agents (MTAs), not the MLM.  Large capacities can impose some
specialized performance demands on the MLM, of course.  The speciality
of those demands, however, enables isolating the optimizations to
select components, and Python's compiled-language extensibility
enables hardening those specific components as needed, isolating the
rigidity to the particular subsystems that need it.

Why Python?

Python is particularly well suited to to implementing an extensive and
changing system.  Its combination of clean syntax and cogent semantics
aids the programmer, all the more in the process of changing existing
code.  It is dynamic in many respects, enabling interaction with and
programmatic handling of just about everything in the language.  By
satisfying the needs of prototyping and rapid development, as well as
those of general programming, it can be seen to foster the needs of
"continuous development", where a system needs to continue to grow to
accomodate a changing world.

.+ An Overview of Mailman's Structure

		[klm: barry's stuff will go in here.]

.+ A Selective Tour of Mailman's Versatility

	       MailList Object Composed via Inheritance
		    from Task-Oriented Components

The MailList class is composed by multiple inheritance from a number
of task-oriented component classes, as mixins.  The task oriented
components contain the methods and variable declarations and
initializations related to the functionality of a particular
subsystem, for example, that of the delivery mechanism or of the mail
commands handler.  This enables easy sharing of their methods and data
throughout the MailList object.  It avoids the need to explicitly
identify and pass around, for example, delegate instances, in order to
use those component's data and methods.

Having all the methods and data inhabit the namespace of the primary
MailList instance can lead to inadvertant name collisions.  However,
we feel that the system would have to get much bigger before that
would become a practical concern, and then we could use naming
conventions to prevent the collisions while still enjoying the easy
sharing without explicit passing of delegate instances.  This use of
multiple inheritance provides this direct sharing along with
organization of the system in distinct, conceptually motivated
modules, easing debugging and development.

		  MailList Object State Persistence
	      Exploits Introspection And Simple Sharing

This direct sharing also simplifies the maillist object's persistence
mechanism.  By identifying its own data members via self.__dict__, the
maillist object's persistence mechanism saves and restores maillist
state using a marshal.  (Members that should not be saved are
distinguished with a leading "_" underscore.)  This exploits Python's
introspection capabilities, as well as a standard, simple persistent
storage facility.  (The higher level standard persistent storage
mechanism, pickle, would do more work than we want or need, so we were
able to avoid its overhead.)  As with sharing in the first place, the
arrangement is uncomplicated, easing approach and acquaintance by
newcomers.

	  Programming and Interacting With MailList Objects

.  : "Scripting" - ie high-level programming that manipulates
     maillists from other applications.  All of the 
.  : Interaction - *great* for development code/test/debugging cycle, with
     actual maillists
.  : Able to examine and exercise pinpoint components

Logging Mechanism

 - Most of the interaction with mailman is triggered remotely - via
   the web or email - making failures hard to trace.  Of course, every 
   program should be perfect (:-), or at least fail gracefully.
   However, when programming for change, particularly in this remotely 
   accessed environment, we need to provide for definite, clear
   feedback in the case of failure.  Mailman uses a comprehensive
   logging mechanism which provides definite and informative feedback
   both to the administrator and to users in the event of most kinds
   of unanticipated program failures.

 - Capitalizes on high-level exception mechanism, polymorphism,
   standard file-object protocol.

			    Web Interface

Mailman provides an interface to MailList objects via CGI, extending
programmatic access to MailList objects to the World Wide Web.  The
MailList component, HTMLFormatter, contains maillist-specific HTML
widgets, built upon an HTML widget library, also included in mailman.
The underlying library provides a modest but encompassing assortment
of HTML document presentation and CGI form widgets, as well as cookies
for authentication.  By building upon such a general mechanism, any
aspects of maillist operation can be extended to the Web.

For starters, we make simple web-related functionality, like overview
of the maillists on the site, and review and subscription to
particular lists, available via the web.  In addition, we also extend
administrative customization of maillist operation (see [configuration
options], below), administrative action on the disposition of
subscriptions and postings being held for approval, and subscriber
control of their subscription status, customization options, and
password.

Configuration Options Mechanism Exploits Namespace Dynamicism

One significant subsystem demonstrating interfacing MailList objects
and the web is the maillist customization-options mechanism.

Sets of configuration options are expressed as lists of tuples, each
tuple specifying the name of the data member which contains the
underlying setting, the type and layout of the element that will
represent it in the HTML user interface, a brief description of the
option, and optional (ie, elective) elaborate description of the
option.  (The option lists also include string entries which are used
to annotate their presentation, typically at least including a header
describing the category of the set.)  Python's dynamic namespaces
enables this simple mechanism to couple external user interface with
the underlying data member.

The elementary nature of the mechanism, in turn, simplifies the
process of adding new configuration variables or changing existing
ones - a common occurrence when new features are added or existing
ones are changed.

The formal structuring of the options has provided another benefit -
it enables central enhancement of the options mechanism as a whole.
One recent example is addition of a help mechanism, which entailed
adding the optional slot for elaborate descriptions and a
corresponding addition to the presentation mechanism to offer help for
those variables that contain the elaborate description.

These option description tables could and should be divided into
plugin directories, to further separate the introduction of new
options from the main body of the program, enabling two benefits:

 - Isolation of the program from disruption due to faults in the
   option descriptions (which tend to be changed more commonly than
   other parts of the program).

 - Reevaluation of the option descriptions while the program is
   running (which will be particularly useful when the program is able 
   to run as a persistent daemon)

A language lacking a dynamic 'eval' which can access and effect a
runtime namespaces could not do any of this without significant
indirection, hence obtuseness in the code.

.+ Conclusion

In effect, the need for the continuing evolution of an MLM suggests a
model with at least parts of the production system - the parts that
need to be fluid - perpetually in the prototype stage of evolution.
Mature prototypes - well exercised and integrated - but amenable to
continuing, and possibly deep, change.  Prototyping and rapid
development are among Python's clear strengths, and invaluable in this
regard.  Mailman exploits multiple inheritance, polymorphism,
high-level control structures like exceptions, conventional protocols,
dynamic access to namespaces, cogent data structures, standard
libraries, and perhaps most of all (but hardest to pinpoint), Python
uncluttered syntax and layout, to provide sophisticated functionality
while maintaining approachable, untortured code.  We have a the bazaar
thing going, and it's good.
