Mailman - Extensibility and Python
 (was Mailman and the Potency of a Python-Powered MLM)

.+ Motivation: Internet dynamicism calls for adaptable MLMs

From the early days of the ARPAnet to today, email and Mailing List
Management (MLM) systems have played a crucial role in the formation
and conduct of communities on the internet.  With the profound
dynamicism of the internet, the form of those communities has
tremendous potential for continued growth and evolution.  The extent
to which MLMs are versatile and adaptable is the extent to which they
can accomodate, and even foster, effective new forms of community
organization.  Mailman is well suited to such evolution, and one of
the contributing features is its basis in Python.

In this paper we will look at various ways the versatility of the
system enables extension of it, considering how the system's design
and its implementation language, Python, factor into it.

. - Why Versatility?

Why is extensibility important in a contemporary MLM?  It is because
of the explosive growth in the internet community, and the core role
that email plays in it.  The internet community is growing, and the
infrastructures by which it organizes are evolving.  Over time,
changes in the scale and development of improved and new strategies
for organizing of internet communities demand continuing development
of the mechanisms supporting them.  A good MLM will foster that
evolution by growing with it.

Another reason the importance of extensibility's has to do with a core
constituency of the maillist users - the maillist administrators.
These administrators are typically near enough to the end-users to get
clear impressions of their needs.  Also, they commonly are savvy
enough, technically, to be able to implement improvements to
accomodate those needs - provided the system doesn't present too high
a threshold of comprehension.  Here is a prime opportunity for
exploiting the Bazaar-style of system development [klm: cite esr's
paper], enabling the managers of the medium, themselves, to guide its
development, so it can be closely tailored to the needs of the
community using it.

Finally, most aspects of an MLM do not require the kind of speed
optimizations which force change-impeding hardening of system.
Performance critical aspects, like mail delivery to large numbers of
users, is generally the purview of the underlying Mail Transport
Agents (MTAs), not the MLM.  Large capacities can impose some
specialized performance demands on the MLM, of course.  The speciality
of those demands, however, enables isolating the optimizations to
select components, and Python's compiled-language extensibility
enables hardening those specific components as needed, isolating the
rigidity to the particular subsystems that need it.

. - Why Python?

Python is particularly well suited to to implementing an extensive and
changing system.  Its combination of clean syntax and cogent semantics
aids the programmer, all the more in the process of changing existing
code.  It is dynamic in many respects, enabling interaction with and
programmatic handling of just about everything in the language.  By
satisfying the needs of prototyping and rapid development, as well as
those of general programming, it can be seen to foster the needs of
"continuous development", where a system needs to continue to grow to
accomodate a changing world.

.+ An Overview of Mailman's Structure

. - MailList class and mixins

. - Configuration variables
.  : default values and site configuration - Defaults.py vs mm_cfg.py
.  : Option declarations
.   . Persistent storage
.   . User interface - maillist administrator
.  : Pending issues?

. - Filtering of postings
.  : All postings of dubious character are held for admin approval
.  : Dubious character is configurable according to sections of a
     filter routine
.  : New filtering mechanisms, eg spam protection, have been added
.  : Probably better as a hook-list of filters, which are passed the
     list object, to obtain configuration state, and the posting
     object. 

. - Security

. - Web interfaces
.  : HTMLFormatter
.  : htmlformat.py library

. - Mail interface

. - Etc...

.+ Highlights of Mailman's System Versatility

. - MailList object composed of Task-oriented mixin classes
.  : Enables compartmentalizing while maintaining easy sharing

	       MailList Object Composed via Inheritance
		    from Task-Oriented Components

The MailList class is composed by multiple inheritance from a number
of task-oriented component classes, as mixins.  The task oriented
components contain the methods and variable declarations and
initializations related to the functionality of a particular
subsystem, for example, that of the delivery mechanism or of the mail
commands handler.  This enables easy sharing of their methods and data
throughout the maillist object.  It avoids the need to explicitly
identify and pass around, for example, delegate instances, in order to
use those component's data and methods.

Having all the methods and data inhabit the namespace of the primary
MailList instance can lead to inadvertant name collisions.  However,
we feel that the system would have to get much bigger before that
would become a practical concern, and then we could use naming
conventions to prevent the collisions while still enjoying the easy
sharing without explicit passing of delegate instances.  This use of
multiple inheritance provides this direct sharing along with
organization of the system in distinct, conceptually motivated
modules, easing debugging and development.

		  MailList Object State Persistence
	      Exploits Introspection And Simple Sharing

This direct sharing also simplifies the maillist object's persistence
mechanism.  Exploiting the ability of a Python class instance to
identify its data members via self.__dict__, the persistence mechanism
save and restores maillist state using a familiar standard python
mechanism, marshal.  (Members that should not be saved are
distinguished with a leading "_" underscore.)  As with sharing in the
first place, the simplicity of the arrangement is uncomplicated,
easing approach and acquaintence by newcomers - prospective
contributors to the closer tailoring of the system to the user's
needs.

Configuration Options Mechanism Exploits Namespace Dynamicism

Yet another important subsystem, the maillist customization-options
mechanism, benefits from the elementary expression of the maillist
state, and the ability to dynamically couple that with internal
maillist state. 

Sets of configuration options are expressed as lists of tuples, each
tuple specifying the name of the data member which contains the
underlying setting, the type and layout of the element that will
represent it in the HTML user interface, a brief description of the
option, and optional (ie, elective) elaborate description of the
option.  (The option lists also include string entries which are used
to annotate their presentation, typically at least including a header
describing the category of the set.)  Python's dynamic namespaces
enables this simple mechanism to couple external user interface with
the underlying data member.

The elementary nature of the mechanism, in turn, simplifies the
process of adding new configuration variables or changing existing
ones - a common occurrence when new features are added or existing
ones are changed.

The formal structuring of the options has provided another benefit -
it enables central enhancement of the options mechanism as a whole.
One recent example is addition of a help mechanism, which entailed
adding the optional slot for elaborate descriptions and a
corresponding addition to the presentation mechanism to offer help for
those variables that contain the elaborate description.

These option description tables could and should be divided into
plugin directories, to further separate the introduction of new
options from the main body of the program, enabling two benefits:

 - Isolation of the program from disruption due to faults in the
   option descriptions (which tend to be changed more commonly than
   other parts of the program).

 - Reevaluation of the option descriptions while the program is
   running (which will be particularly useful when the program is able 
   to run as a persistent daemon)

A language lacking a dynamic 'eval' which can access and effect a
runtime namespaces could not do any of this without significant
indirection, hence obtuseness in the code.

			    Web Interface

The web interface, itself, capitalizes on the standard python HTML and
CGI libraries. 
. - HTML generation library and abstractions

.  : Enables tieing together web pages and forms with maillist state,
     and enables us to provide list administrator editing of those
     pages and forms via the web.
.  : Possible due to powerful python libraries - html, cgi, etc - and
     dynamic access to variables

			  Logging Mechanism

.  : Generic wrapper that mediates all web and email interfaces,
     providing automatically for, among other things, sensible logging
     of system errors.
.  : Enabled because of polymorphism and standard file-object protocol

. - Interaction with maillists programmatically

.  : "Scripting" - ie high-level programming that manipulates
     maillists from other applications.  All of the 
.  : Interaction - *great* for development code/test/debugging cycle, with
     actual maillists
.  : Able to examine and exercise pinpoint components

.+ Conclusion

Multiple Inheritance, polymorphism, conventional protocols, dynamic
access to namespaces, standard libraries, all have been mentioned
above.  We have not even chimed in about the way the language's
incipient readability contributes to 
afforded by
Python's particularly uncluttered syntax and promotion of a regular
layout, and it's orthogonal, cogent data types and control
constructs.  It is harder to substantiate this with specific examples, 
but can be experienced by anyone who spends time with this and other
languages.

In effect, the need for the continuing evolution of an MLM suggests a
model with at least parts of the production system - the parts that
need to be fluid - perpetually in the prototype stage of evolution.
*Mature* prototypes - well exercised and integrated - but amenable to
continuing, and possibly deep, change.  Prototyping and rapid
development are among Python's clear strengths, and invaluable in this
regard.]

.+ Local emacs vars.
. - (`outline-layout' is for allout.el outline-mode)
. - Local variables:
. - outline-layout: (-1 : 0)
. - End:
