Email addresses
===============

Addresses represent a text email address, along with some meta data about
those addresses, such as their registration date, and whether and when they've
been validated.  Addresses may be linked to the users that Mailman knows
about.  Addresses are subscribed to mailing lists though members.

    >>> from Mailman.database import flush
    >>> from Mailman.configuration import config
    >>> mgr = config.user_manager


Creating addresses
------------------

Addresses are created directly through the user manager, which starts out with
no addresses.

    >>> sorted(address.address for address in mgr.addresses)
    []

Creating an unlinked email address is straightforward.

    >>> address_1 = mgr.create_address('aperson@example.com')
    >>> flush()
    >>> sorted(address.address for address in mgr.addresses)
    ['aperson@example.com']

However, such addresses have no real name.

    >>> address_1.real_name
    ''

You can also create an email address object with a real name.

    >>> address_2 = mgr.create_address('bperson@example.com', 'Ben Person')
    >>> flush()
    >>> sorted(address.address for address in mgr.addresses)
    ['aperson@example.com', 'bperson@example.com']
    >>> sorted(address.real_name for address in mgr.addresses)
    ['', 'Ben Person']

The str() of the address is the RFC 2822 preferred originator format, while
the repr() carries more information.

    >>> str(address_2)
    'Ben Person <bperson@example.com>'
    >>> repr(address_2)
    '<Address: Ben Person <bperson@example.com> [not verified] at 0x...>'

You can assign real names to existing addresses.

    >>> address_1.real_name = 'Anne Person'
    >>> flush()
    >>> sorted(address.real_name for address in mgr.addresses)
    ['Anne Person', 'Ben Person']

These addresses are not linked to users, and can be seen by searching the user
manager for an associated user.

    >>> print mgr.get_user('aperson@example.com')
    None
    >>> print mgr.get_user('bperson@example.com')
    None

You can create email addresses that are linked to users by using a different
interface.

    >>> user_1 = mgr.create_user('cperson@example.com', 'Claire Person')
    >>> flush()
    >>> sorted(address.address for address in mgr.addresses)
    ['aperson@example.com', 'bperson@example.com', 'cperson@example.com']
    >>> sorted(address.real_name for address in mgr.addresses)
    ['Anne Person', 'Ben Person', 'Claire Person']

And now you can find the associated user.

    >>> print mgr.get_user('aperson@example.com')
    None
    >>> print mgr.get_user('bperson@example.com')
    None
    >>> mgr.get_user('cperson@example.com')
    <User "Claire Person" at ...>


Deleting addresses
------------------

You can remove an unlinked address from the usre manager.

    >>> mgr.delete_address(address_1)
    >>> flush()
    >>> sorted(address.address for address in mgr.addresses)
    ['bperson@example.com', 'cperson@example.com']
    >>> sorted(address.real_name for address in mgr.addresses)
    ['Ben Person', 'Claire Person']

Deleting a linked address does not delete the user, but it does unlink the
address from the user.

    >>> sorted(address.address for address in user_1.addresses)
    ['cperson@example.com']
    >>> user_1.controls('cperson@example.com')
    True
    >>> address_3 = list(user_1.addresses)[0]
    >>> mgr.delete_address(address_3)
    >>> flush()
    >>> sorted(address.address for address in user_1.addresses)
    []
    >>> user_1.controls('cperson@example.com')
    False
    >>> sorted(address.address for address in mgr.addresses)
    ['bperson@example.com']


Registration and validation
---------------------------

Addresses have two dates, the date the address was registered on and the date
the address was validated on.  Neither date is set by default.

    >>> address_4 = mgr.create_address('dperson@example.com', 'Dan Person')
    >>> flush()
    >>> print address_4.registered_on
    None
    >>> print address_4.validated_on
    None

The registered date takes a Python datetime object.

    >>> from datetime import datetime
    >>> address_4.registered_on = datetime(2007, 5, 8, 22, 54, 1)
    >>> flush()
    >>> print address_4.registered_on
    2007-05-08 22:54:01
    >>> print address_4.validated_on
    None

And of course, you can also set the validation date.

    >>> address_4.validated_on = datetime(2007, 5, 13, 22, 54, 1)
    >>> flush()
    >>> print address_4.registered_on
    2007-05-08 22:54:01
    >>> print address_4.validated_on
    2007-05-13 22:54:01


Subscriptions
-------------

Addresses get subscribed to mailing lists, not users.  When the address is
subscribed, a role is specified.

    >>> address_5 = mgr.create_address('eperson@example.com', 'Elly Person')
    >>> mlist = config.list_manager.create('_xtext@example.com')
    >>> from Mailman.constants import MemberRole
    >>> address_5.subscribe(mlist, MemberRole.owner)
    <Member: Elly Person <eperson@example.com> on
             _xtext@example.com as MemberRole.owner>
    >>> address_5.subscribe(mlist, MemberRole.member)
    <Member: Elly Person <eperson@example.com> on
             _xtext@example.com as MemberRole.member>
    >>> flush()

Now Elly is both an owner and a member of the mailing list.

    >>> sorted(mlist.owners.members)
    [<Member: Elly Person <eperson@example.com> on
              _xtext@example.com as MemberRole.owner>]
    >>> sorted(mlist.moderators.members)
    []
    >>> sorted(mlist.administrators.members)
    [<Member: Elly Person <eperson@example.com> on
              _xtext@example.com as MemberRole.owner>]
    >>> sorted(mlist.members.members)
    [<Member: Elly Person <eperson@example.com> on
              _xtext@example.com as MemberRole.member>]
    >>> sorted(mlist.regular_members.members)
    [<Member: Elly Person <eperson@example.com> on
              _xtext@example.com as MemberRole.member>]
    >>> sorted(mlist.digest_members.members)
    []


Case-preserved addresses
------------------------

Technically speaking, email addresses are case sensitive in the local part.
Mailman preserves the case of addresses and uses the case preserved version
when sending the user a message, but it treats addresses that are different in
case equivalently in all other situations.

    >>> address_6 = mgr.create_address('FPERSON@example.com', 'Frank Person')
    >>> flush()

The str() of such an address prints the RFC 2822 preferred originator format
with the original case-preserved address.  The repr() contains all the gory
details.

    >>> str(address_6)
    'Frank Person <FPERSON@example.com>'
    >>> repr(address_6)
    '<Address: Frank Person <FPERSON@example.com> [not verified]
               key: fperson@example.com at 0x...>'

Both the case-insensitive version of the address and the original
case-preserved version are available on attributes of the IAddress object.

    >>> address_6.address
    'fperson@example.com'
    >>> address_6.original_address
    'FPERSON@example.com'

Because addresses are case-insensitive for all other purposes, you cannot
create an address that differs only in case.

    >>> mgr.create_address('fperson@example.com')
    Traceback (most recent call last):
    ...
    ExistingAddressError: FPERSON@example.com
    >>> mgr.create_address('fperson@EXAMPLE.COM')
    Traceback (most recent call last):
    ...
    ExistingAddressError: FPERSON@example.com
    >>> mgr.create_address('FPERSON@example.com')
    Traceback (most recent call last):
    ...
    ExistingAddressError: FPERSON@example.com

You can get the address using either the lower cased version or case-preserved
version.  In fact, searching for an address is case insensitive.

    >>> mgr.get_address('fperson@example.com').address
    'fperson@example.com'
    >>> mgr.get_address('FPERSON@example.com').address
    'fperson@example.com'
