#!/usr/local/bin/python
# Copyright (C) 1998 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""Partition a mass delivery into a suitable set of subdeliveries."""

__version__ = "$Revision: 547 $"

# Heh, heh, heh, this partition reminds me of the knapsack problem ;-)
# Ie, the optimal distribution here is NP Complete.

import os

if not os.fork():
    import string, sys, regsub
    sys.path.append('/home/mailman/mailman/modules')
    import mm_cfg
    def CallSendmail(cmd, stdin):
	file = os.popen(cmd, 'w')
	file.write(stdin)
	file.close()

    domain_info = {}
    def GroupByDomain(addr):
        "Collect addrs by major subdomain - e.g. the 'python' in python.org."
	parts = regsub.split(addr, '[.@]')
	key = string.join(parts[-2:])
        addr = repr(addr)
	if not domain_info.has_key(key):
	    domain_info[key] = [addr]
	else:
	    domain_info[key].append(addr)

    def BuildGroups(biglist, num_addrs):
	biglist.sort(lambda x,y: len(x) < len(y))
	groups = []
	for i in range(spawns-1):
	    target_size = num_addrs / (spawns - i)
	    if not len(biglist):
		break
	    newlist = biglist[0]
	    biglist.remove(biglist[0])
	    j = 0
	    while len(newlist) < target_size:
		if j >= len(biglist):
		    break
		if len(newlist) + len(biglist[j]) > target_size:
		    j = j + 1
		    continue
		newlist = newlist + biglist[j]
		biglist.remove(biglist[j])
	    groups.append(newlist)
	    num_adders = num_addrs - len(newlist)
	lastgroup = []
	for item in biglist:
	    lastgroup = lastgroup + item
	if len(lastgroup):
	    groups.append(lastgroup)
	return groups

    def CallSendmailForEachGroup(groups, sender, text):
	for group in groups:
	    if not os.fork():
		CallSendmail(mm_cfg.SENDMAIL_CMD %
			     (sender, string.join(group)), text)
		os._exit(0)

    sender = sys.argv[2]
    spawns = eval(sys.argv[3])
    if spawns > mm_cfg.MAX_SPAWNS:
	spawns = mm_cfg.MAX_SPAWNS
    if spawns < 1:
	spawns = 1
    to_list = sys.argv[4:]
    try:
        file = open(sys.argv[1], 'r')
    except IOError, msg:
        raise IOError, (msg[0], msg[1], sys.argv[1])
    text = file.read()
    file.close()
    os.unlink(sys.argv[1])

    map(GroupByDomain, to_list)
    final_groups = BuildGroups(domain_info.values(), len(to_list))
    
    CallSendmailForEachGroup(final_groups, sender, text)
