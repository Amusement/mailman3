#! /usr/bin/env python
#
# Copyright (C) 1998,1999,2000 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""Attempt redelivery for all messages that had delivery problems.
"""

import sys
import os
import marshal

import paths
from Mailman import mm_cfg
from Mailman import MailList
from Mailman import LockFile
from Mailman import Message
from Mailman import Errors
from Mailman.Handlers import HandlerAPI
from Mailman.Logging.Utils import LogStdErr


# Work around known problems with some RedHat cron daemons
import signal
signal.signal(signal.SIGCHLD, signal.SIG_DFL)

QRUNNER_LOCK_FILE = os.path.join(mm_cfg.LOCK_DIR, 'qrunner.lock')
QRUNNER_LOCK_LIFETIME = 60 * 10                   # seconds

LogStdErr('error', 'qrunner', tee_to_stdout=0)



def dispose_message(mlist, msg, msgdata):
    # Pre 2.0beta3 qfiles have no schema version number
    version = msgdata.get('version', 0)
    if version < 1:
        return HandlerAPI.RedeliverMessage(mlist, msg)
    return HandlerAPI.DeliverToList(mlist, msg, msgdata)



_listcache = {}
def open_list(listname):
    global _listcache
    mlist = _listcache.get(listname)
    if not mlist:
        try:
            mlist = MailList.MailList(listname, lock=0)
            _listcache[listname] = mlist
        except Errors.MMListError, e:
            sys.stderr.write('qrunner error opening list: %s\n%s\n' %
                             (listname, e))
    return mlist



def dequeue(root):
    # We're done with this message
    os.unlink(root + '.db')
    os.unlink(root + '.msg')



_kids = {}
def main():
    stderr = sys.stderr
    global _kids
    for file in os.listdir(mm_cfg.QUEUE_DIR):
        root, ext = os.path.splitext(os.path.join(mm_cfg.QUEUE_DIR, file))
        if ext <> '.msg':
            # trigger just off the .msg file
            continue
        try:
            msgfp = open(root + '.msg')
            msgtext = msgfp.read()
            msgfp.close()
            dbfp = open(root + '.db')
            msgdata = marshal.load(dbfp)
            dbfp.close()
            # TBD: The `kids' key is special.  It contains the pids of
            # subprocesses that need to be waited on by the delivery module.
            # For implementation ease, it can get stored in the message data,
            # but since this refers to pids not descendent from us, it should
            # just be chucked.
            if msgdata.has_key('kids'):
                del msgdata['kids']
        except (EOFError, ValueError, TypeError, IOError), e:
            # For some reason we had trouble getting all the information out
            # of the queued files.  log this and move on (we figure it's a
            # temporary problem)
            stderr.write('Exception reading qfile: %s\n%s\n' % (root, e))
            continue
        # Dispose of it, after ensuring that we've got the lock on the list.
        listname = msgdata.get('listname')
        if not listname:
            stderr.write('qfile metadata specifies no list: %s\n' % root)
            continue
        mlist = open_list(listname)
        if not mlist:
            stderr.write('Dequeuing message destined for missing list: %s\n'
                         % root)
            dequeue(root)
            continue
        # Now try to get the list lock
        try:
            mlist.Lock(timeout=mm_cfg.LIST_LOCK_TIMEOUT)
        except LockFile.TimeOutError:
            # oh well, try again later
            continue
        try:
            msg = Message.OutgoingMessage(msgtext)
            keepqueued = dispose_message(mlist, msg, msgdata)
            # Did the delivery generate child processes?  Don't store them in
            # the message data files.
            kids = msgdata.get('kids')
            if kids:
                _kids.update(kids)
                del msgdata['kids']
            if not keepqueued:
                # We're done with this message
                dequeue(root)
        finally:
            mlist.Save()
            mlist.Unlock()



if __name__ == '__main__':
    global _listcache
    global _kids
    # first, claim the queue runner lock
    lock = LockFile.LockFile(QRUNNER_LOCK_FILE, lifetime=QRUNNER_LOCK_LIFETIME)
    try:
        lock.lock(timeout=0.5)
    except LockFile.TimeOutError:
        # TBD: It is possible that some other process has laid claim to the
        # gate lock for this list, but that said process has exited uncleanly.
        # If that's the case, and it leaves it's lock claim on disk, we will
        # never be able to gate from usenet to the list again, until the stale
        # lock is removed.  For now, we just log this potentially deadlocked
        # situation, but this should really be fixed (probably in LockFile.py
        # though).
        sys.stderr.write('Could not acquire qrunner lock\n')
    else:
        try:
            main()
        finally:
            lock.unlock(unconditionally=1)
            # Clear the global cache to be clean about it.  Also, we can reap
            # any child processes that were created during the delivery
            # (e.g. from ToUsenet).
            _listcache.clear()
            while _kids:
                pid, status = os.waitpid(-1, os.WNOHANG)
                if pid <> 0:
                    del _kids[pid]
