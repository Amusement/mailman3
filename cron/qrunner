#! /usr/bin/env python
#
# Copyright (C) 1998,1999,2000,2001 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# NOTE: This script should really be removed from the cron/ subdirectory
# because it is no longer started from cron.  However, now that the CVS
# repository is at SF, that's too much of a pain, so hence the bogus location
# in the source tree.

"""Master queue runner watchdog.

This script should be started from an init script.  It simply makes sure that
the various long-running qrunners are still alive and kicking.  It does this
by forking the individual qrunners and waiting on their pids.  When it detects
a subprocess has exited, it will restart it.

The master qrunner will leave its process id in the file data/qrunner.pid
which can be used to shutdown or HUP the qrunner daemon.  Sending a SIGINT to
the master qrunner causes it and all sub-qrunners to exit.  Sending a SIGHUP
causes the master to re-open all of its log files, and to SIGINT kill and
restart all sub-qrunners processes.

You can substitute your own queue management system for qrunner, or you can
edit this file to tailor which Mailman qrunners actually get started.  This
way you can say, drop in your own archiver qrunner or your own outgoing
qrunner, or define entirely new qrunner paths through the system.  The only
one that's required is the IncomingRunner, which handles passing a message
through the Mailman system.

The set of queues are defined in Defaults.py.

When run as a script, the follow usage is allowed:

Usage: qrunner [options]

Options:

    -r runnername
    --runner=runnername
        Run the named qrunner exactly once.  runnername is the name of a
        module in the Mailman.Queue package, but it should be just the first
        part of the package name (i.e. sans `Runner').  E.g.

            qrunner -r Virgin

        runs the Mailman.Queue.VirginRunner qrunner once.  With no -r flag,
        this starts the qrunner watchdog master script.  You should not use
        the -r if there is already a master qrunner running.

    -n/--no-restart
        Don't restart queue runners when they exit because of an error.  Use
        this only for debugging.

    -h/--help
        Print this help message and exit.
"""

import sys
import os
import getopt
import errno
import time
import signal

import paths
from Mailman import mm_cfg
from Mailman import Utils
from Mailman import LockFile
from Mailman import i18n
from Mailman.Logging.Syslog import syslog
from Mailman.Logging.Utils import LogStdErr

_ = i18n._
i18n.set_language(mm_cfg.DEFAULT_SERVER_LANGUAGE)

LOCKFILE = os.path.join(mm_cfg.LOCK_DIR, 'master-qrunner')
PIDFILE = os.path.join(mm_cfg.DATA_DIR, 'qrunner.pid')
LOCK_LIFETIME = mm_cfg.days(10)
SNOOZE = mm_cfg.days(1)

COMMASPACE = ', '

# We want a SIGHUP to re-open all the log files.  By closing syslog, it will
# cause a new StampedLogger to be opened the next time a message is logged.
def sighup_handler(signum, frame):
    syslog.close()
    # SIGINT all the children so that they'll restart automatically.
    for pid in KIDS.keys():
        os.kill(pid, signal.SIGINT)
    # And just to tweak things...
    syslog('qrunner', 'qrunner caught SIGHUP.  Re-opening log files.')

signal.signal(signal.SIGHUP, sighup_handler)

# Global dictionary mapping child pids to (qrclass, slice, count)
KIDS = {}



def usage(code, msg=''):
    print >> sys.stderr, _(__doc__)
    if msg:
        print >> sys.stderr, msg
    sys.exit(code)



def start_runner(qrclass, slice, count):
    pid = os.fork()
    if pid:
        # parent
        syslog('qrunner', '%s qrunner started with pid: %d', qrclass, pid)
        return pid
    else:
        # child
        try:
            qrunner = qrclass(slice, count).run()
            syslog('qrunner', '%s qrunner exiting', qrclass)
        except KeyboardInterrupt:
            # Due to race conditions, the subproc could get the SIGINT inside
            # the syslog call.  It's of no consequence.
            pass
        os._exit(0)



def start_lock_refresher(lock):
    # This runs in its own subprocess, and it owns the global qrunner lock.
    pid = os.fork()
    if pid:
        # parent
        return pid
    # In the child, we simply wake up once per day and refresh the lock
    try:
        while 1:
            lock.refresh()
            time.sleep(SNOOZE)
    except KeyboardInterrupt:
        pass
    os._exit(0)



def master(restart, lock):
    # Start up the lock refresher process
    watchdog_pid = start_lock_refresher(lock)
    # Start up all the qrunners
    for classname, count in mm_cfg.QRUNNERS:
        modulename = 'Mailman.Queue.' + classname
        __import__(modulename)
        qrclass = getattr(sys.modules[modulename], classname)
        for slice in range(count):
            info = (qrclass, slice, count)
            pid = start_runner(qrclass, slice, count)
            KIDS[pid] = info
    # Now just wait for children to end, but also catch KeyboardInterrupts
    if restart:
        restarting = '[restarting]'
    else:
        restarting = ''
    try:
        try:
            while 1:
                try:
                    pid, status = os.wait()
                except OSError, e:
                    if e.errno <> errno.EINTR: raise
                    # Just restart the wait()
                    continue
                killsig = status & 0xff
                exitstatus = (status >> 8) & 0xff
                # What should we do with this information other than log it?
                if pid == watchdog_pid:
                    syslog('qrunner', '''\
qrunner watchdog detected lock refresher exit
    (pid: %d, sig: %d, sts: %d) %s''', 
                           pid, killsig, exitstatus, restarting)
                    if restart:
                        watchdog_pid = start_lock_refresher(lock)
                else:
                    qrclass, slice, count = KIDS[pid]
                    syslog('qrunner', '''\
qrunner watchdog detected subprocess exit
    (pid: %d, sig: %d, sts: %d, class: %s, slice %d of %d) %s''',
                           pid, killsig, exitstatus, qrclass, slice, count,
                           restarting)
                    del KIDS[pid]
                    # Now perhaps restart the process
                    if restart:
                        newpid = start_runner(qrclass, slice, count)
                        KIDS[newpid] = (qrclass, slice, count)
        except KeyboardInterrupt:
            pass
    finally:
        # Should we leave the main loop for any reason, we want to be sure all
        # of our children are exited cleanly.  Send SIGINTs to all the child
        # processes and wait for them all to exit.  Include the watchdog!
        KIDS[watchdog_pid] = watchdog_pid
        for pid in KIDS.keys():
            try:
                os.kill(pid, signal.SIGINT)
            except OSError, e:
                if e.errno == errno.ESRCH:
                    # The child has already exited
                    del KIDS[pid]
        # Wait for all the children to go away
        Utils.reap(KIDS)



def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'hr:n',
                                   ['help', 'runner=', 'no-restart'])
    except getopt.error, msg:
        usage(1, msg)

    runner = None
    restart = 1
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage(0)
        elif opt in ('-r', '--runner'):
            runner = arg
        elif opt in ('-n', '--no-restart'):
            restart = 0

    if args:
        usage(1, _('Bad arguments: %s' % COMMASPACE.join(args)))

    if runner is None:
        # If we're running as a long-running process in the background, stderr
        # should go to the error log file.  Otherwise it should continue to go
        # to stderr.
        LogStdErr('error', 'qrunner', manual_reprime=0)

    # Be sure we can acquire the master qrunner lock.  If not, it means some
    # other master qrunner daemon is already going.  This isn't allowed even
    # if we're doing a one-shot runner via -r.
    lock = LockFile.LockFile(LOCKFILE, LOCK_LIFETIME)
    try:
        lock.lock(0.5)
    except LockFile.TimeOutError:
        print >> sys.stderr, 'Another qrunner is already running, exiting.'
        sys.exit(0)

    if runner is None:
        # Run master in the foreground, storing our own pid in the pid file
        fp = open(PIDFILE, 'w')
        print >> fp, os.getpid()
        fp.close()
        master(restart, lock)
        os.unlink(PIDFILE)
        return
    else:
        # One-shot
        classname = runner + 'Runner'
        modulename = 'Mailman.Queue.%s' % classname
        try:
            __import__(modulename)
        except ImportError:
            print >> sys.stderr, 'Qrunner module not found:', modulename
            raise
        class_ = getattr(sys.modules[modulename], classname)
        # Subclass to hack in the setting of the stop flag in the
        # _doperiodic() subclass.
        class Once(class_):
            def _doperiodic(self):
                self.stop()
        runner = Once()
        runner.run()



if __name__ == '__main__':
    main()
