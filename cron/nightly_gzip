#! /usr/bin/env python
# 
# Copyright (C) 1998 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
"""Re-generate the Pipermail gzip'd archive flat files.

This script should be run nightly from cron.  When run from the command line,
the following usage is understood:

Usage: %(program)s [-a] [-h] [listnames]

Where:
    --all
    -a
        gzip all the flat .txt archives files.  Without this, only the
        chronologically latest named .txt file is compressed for each list.

    --verbose
    -v
        print each file as it's being gzip'd

    --help
    -h
        print this message and exit

    listnames
        Optionally, only compress the .txt files for the named lists.  Without 
        this, all archivable lists are processed.

"""

import sys
import os
import time
import getopt
gzip = None
try:
    import gzip
except ImportError:
    pass
import paths
from Mailman import MailList
from Mailman import Utils
from Mailman import mm_cfg



program = sys.argv[0]
VERBOSE = 0

def usage(code, msg=''):
    print __doc__ % globals()
    if msg:
        print msg
    sys.exit(code)



def sortfunc(a, b):
    f1, y1, m1 = a
    f2, y2, m2 = b
    return cmp((y2, m2), (y1, m1))



def compress(txtfile):
    if VERBOSE:
        print "gzip'ing:", txtfile
    infp = open(txtfile)
    outfp = gzip.open(txtfile+'.gz', 'wb', 6)
    outfp.write(infp.read())
    outfp.close()
    infp.close()



def main():
    global VERBOSE
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'avh',
                                   ['all', 'verbose', 'help'])
    except getopt.error, msg:
        usage(1, msg)

    # defaults
    all = 0
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage(0)
        elif opt in ('-a', '--all'):
            all = 1
        elif opt in ('-v', '--verbose'):
            VERBOSE = 1

    # limit to the specified lists?
    if args:
        listnames = args
    else:
        listnames = Utils.list_names()

    # process all the specified lists
    for name in listnames:
        mlist = MailList.MailList(name, lock=0)
        if not mlist.archive:
            continue
        dir = mlist.archive_directory
        allfiles = os.listdir(dir)
        files = []
        for f in allfiles:
            try:
                year, month = time.strptime(f, '%Y-%B.txt')[0:2]
            except ValueError:
                pass
            else:
                files.append((os.path.join(dir, f), year, month))
        if not files:
            continue
        if all:
            for f, m, y in files:
                compress(f)
        else:
            files.sort(sortfunc)
            f, m, y = files[0]
            compress(f)

        

if __name__ == '__main__' and \
   gzip is not None and \
   mm_cfg.ARCHIVE_TO_MBOX in (1, 2) and \
   not mm_cfg.GZIP_ARCHIVE_TXT_FILES:
    # we're only going to run the nightly archiver if messages are archived to
    # the mbox, and the gzip file is not created on demand (i.e. for every
    # individual post).  This is the normal mode of operation.  Also, be sure
    # we can actually import the gzip module!
    omask = os.umask(002)
    try:
        main()
    finally:
        os.umask(omask)
