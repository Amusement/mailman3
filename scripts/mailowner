#! /usr/bin/env python
#
# Copyright (C) 1998,1999,2000 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""Send a message to the mailing list owner.

This script gets called by the wrapper.

Stdin is the mail message, and argv[1] is the name of the mailing list
whose owner(s) to send mail to.
"""


import sys
import mimetools

import paths
from Mailman import mm_cfg
from Mailman import MailList
from Mailman import Message
from Mailman import Errors
from Mailman.Handlers import HandlerAPI
from Mailman.Bouncers import BouncerAPI
from Mailman.Logging.Utils import LogStdErr
from Mailman.pythonlib.StringIO import StringIO

LogStdErr('error', 'post')



def main():
    try:
        listname = sys.argv[1]
    except IndexError:
        sys.stderr.write('Mailman error: mailowner got no listname.\n')
        sys.exit(1)
    try:
        mlist = MailList.MailList(listname, lock=0)
    except Errors.MMListError, e:
        sys.stderr.write('Mailman error: mailowner got bad listname: %s\n%s' %
                         (listname, e))
        sys.exit(1)
    # Try to obtain the mailing list lock.  If that fails, enqueue the message
    # for delivery by the qrunner cron job.
    try:
        mlist.Lock(timeout=mm_cfg.LIST_LOCK_TIMEOUT)
    except LockFile.TimeOutError:
        msg.Enqueue(mlist)
        return
    try:
        s = StringIO(sys.stdin.read())
        msg = mimetools.Message(s)
        if mlist.bounce_processing:
            if BouncerAPI.ScanMessages(mlist, msg):
                return
        # okay, no bounces were detected, but we have to convert this
        # mimetools.Message thingie to one of our OutgoingMessages.
        msg = Message.OutgoingMessage(s.getvalue())
        recips = mlist.owner[:]
        # debugging
        #recips.append(mm_cfg.MAILMAN_OWNER)
        msgdata = {'recips' : recips,
                   'toadmin': 1,
                   }
        enqueue = HandlerAPI.DeliverToUser(mlist, msg, msgdata)
        if enqueue:
            msg.Enqueue(mlist, newdata=msgdata)
    finally:
        mlist.Save()
        mlist.Unlock()



if __name__ == '__main__':
    main()
